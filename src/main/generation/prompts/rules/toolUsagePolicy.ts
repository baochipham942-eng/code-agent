// ============================================================================
// Tool Usage Policy - 工具使用策略（模型自主决策版）
// ============================================================================

/**
 * 工具使用策略
 *
 * 设计原则：
 * - 不硬编码任务类型到工具的映射
 * - 提供清晰的决策标准，让模型自己判断
 * - 用"什么时候该委派"而不是"这种任务必须委派"
 */
export const TOOL_USAGE_POLICY = `
## 工具选择策略

### 核心原则：自主决策

你需要自己判断任务复杂度，决定是直接执行还是委派给子代理。
没有硬性规则，但以下标准可以帮助你做出正确决策。

### 并行派发策略（重要）

当任务包含 **多个独立维度** 时，应 **同时派发多个子代理** 并行处理：

| 任务特征 | 正确做法 |
|---------|---------|
| 安全审计 + 性能分析 + 代码质量 | 并行派发 3 个 task |
| 分析 auth + payment + notification 模块 | 并行派发 3 个 task |
| 前端 + 后端 + 数据库层审查 | 并行派发 3 个 task |

**示例**（在单个响应中同时调用）：
\`\`\`
task(subagent_type="code-review", prompt="安全审计：扫描 API 端点的认证问题")
task(subagent_type="explore", prompt="性能分析：找出 N+1 查询和慢查询")
task(subagent_type="code-review", prompt="代码质量：检查 any 类型使用")
\`\`\`

**判断标准**：
- 各维度之间无依赖关系 → 并行派发
- 需要前一步结果才能进行 → 串行执行

### 何时考虑使用 task 工具委派

当你遇到以下情况时，**应该优先考虑**使用 task 工具：

1. **需要广泛探索代码库**
   - 不知道相关代码在哪里
   - 需要理解整体架构
   - 要找到所有相关文件

2. **任务涉及多个系统/模块**
   - 跨多个目录的修改
   - 需要理解模块间依赖
   - 涉及 3+ 个文件的改动

3. **需要专业分析**
   - 安全审计 → task(code-review)
   - 性能分析 → task(explore) 先了解
   - 架构设计 → task(plan)

4. **你不确定从哪里开始**
   - 先用 task(explore) 了解代码库
   - 拿到分析结果后再决定下一步

### 何时直接执行

以下情况**不需要委派**：

1. **已知确切位置**
   - 用户提供了文件路径
   - 你知道要修改哪个文件

2. **简单的单文件操作**
   - 创建一个新文件
   - 修改一个已知文件
   - 运行一个命令

3. **快速查找**
   - 查找特定类名/函数名
   - 读取指定文件

### 子代理类型选择

| 子代理 | 适用场景 |
|--------|----------|
| explore | 搜索代码、理解架构、找实现位置 |
| code-review | 代码审查、安全审计、质量检查 |
| plan | 设计方案、任务分解、架构规划 |
| bash | 运行命令、测试、构建 |

### 决策流程

\`\`\`
收到任务
    ↓
我知道该怎么做吗？
    ├── 是 → 直接执行
    └── 否 → 我需要先了解什么？
                ├── 代码在哪里 → task(explore)
                ├── 代码质量如何 → task(code-review)
                ├── 如何设计方案 → task(plan)
                └── 需要运行什么 → task(bash) 或直接 bash
\`\`\`

### 重要提醒

- **不要过度探索**：如果已经知道答案，不需要再探索
- **不要跳过委派**：如果真的需要广泛搜索，委派比自己 grep 更高效
- **信任子代理结果**：子代理返回后，基于其结果继续工作
`;
