// ============================================================================
// AutoPlanner - Automatic task decomposition and planning service
// Enhancement 5: Intelligent Task Decomposition & Planning
// ============================================================================

import type {
  TaskPlan,
  TaskPhase,
  TaskStep,
  PlanningConfig,
} from './types';
import type { TaskComplexity, ComplexityAnalysis } from './TaskComplexityAnalyzer';
import { taskComplexityAnalyzer } from './TaskComplexityAnalyzer';
import { getEvolutionPersistence } from '../services/EvolutionPersistence';

// ============================================================================
// Types
// ============================================================================

// Template step only requires content
interface TemplateStep {
  content: string;
}

// Template phase has simplified structure
interface TemplatePhase {
  title: string;
  steps: TemplateStep[];
  notes?: string;
}

export interface PlanTemplate {
  id: string;
  name: string;
  description: string;
  complexity: TaskComplexity;
  phases: TemplatePhase[];
  tags: string[];
}

export interface AutoPlanResult {
  plan: TaskPlan;
  template?: PlanTemplate;
  complexity: ComplexityAnalysis;
  autoGenerated: boolean;
}

export interface AutoPlannerConfig {
  enableAutoPlanning: boolean;
  complexityThreshold: TaskComplexity; // Minimum complexity to trigger auto-planning
  useTemplates: boolean;
  maxStepsPerPhase: number;
  persistPlans: boolean;
}

const DEFAULT_CONFIG: AutoPlannerConfig = {
  enableAutoPlanning: true,
  complexityThreshold: 'moderate',
  useTemplates: true,
  maxStepsPerPhase: 8,
  persistPlans: true,
};

// ============================================================================
// Built-in Plan Templates
// ============================================================================

const PLAN_TEMPLATES: PlanTemplate[] = [
  {
    id: 'feature-development',
    name: 'Feature Development',
    description: 'Standard workflow for adding new features',
    complexity: 'moderate',
    tags: ['feature', 'add', 'implement', 'new', 'create'],
    phases: [
      {
        title: 'Analysis',
        steps: [
          { content: 'Understand the feature requirements' },
          { content: 'Identify affected files and components' },
          { content: 'Check for existing patterns to follow' },
        ],
      },
      {
        title: 'Implementation',
        steps: [
          { content: 'Create/modify necessary files' },
          { content: 'Implement core logic' },
          { content: 'Add error handling' },
        ],
      },
      {
        title: 'Verification',
        steps: [
          { content: 'Test the implementation' },
          { content: 'Check for edge cases' },
        ],
      },
    ],
  },
  {
    id: 'bug-fix',
    name: 'Bug Fix',
    description: 'Standard workflow for fixing bugs',
    complexity: 'simple',
    tags: ['bug', 'fix', 'error', 'issue', 'broken', 'not working'],
    phases: [
      {
        title: 'Investigation',
        steps: [
          { content: 'Reproduce the bug' },
          { content: 'Identify root cause' },
        ],
      },
      {
        title: 'Fix',
        steps: [
          { content: 'Apply the fix' },
          { content: 'Verify fix resolves the issue' },
        ],
      },
    ],
  },
  {
    id: 'refactoring',
    name: 'Code Refactoring',
    description: 'Standard workflow for refactoring code',
    complexity: 'complex',
    tags: ['refactor', 'restructure', 'reorganize', 'clean', 'improve'],
    phases: [
      {
        title: 'Analysis',
        steps: [
          { content: 'Map current code structure' },
          { content: 'Identify code smells and issues' },
          { content: 'Design target structure' },
        ],
      },
      {
        title: 'Preparation',
        steps: [
          { content: 'Create backup/branch' },
          { content: 'Ensure tests exist' },
        ],
      },
      {
        title: 'Refactoring',
        steps: [
          { content: 'Apply refactoring changes incrementally' },
          { content: 'Update imports and references' },
          { content: 'Fix any breaking changes' },
        ],
      },
      {
        title: 'Verification',
        steps: [
          { content: 'Run all tests' },
          { content: 'Check for regressions' },
          { content: 'Review changes' },
        ],
      },
    ],
  },
  {
    id: 'api-integration',
    name: 'API Integration',
    description: 'Standard workflow for integrating APIs',
    complexity: 'complex',
    tags: ['api', 'integrate', 'connect', 'service', 'endpoint'],
    phases: [
      {
        title: 'Research',
        steps: [
          { content: 'Review API documentation' },
          { content: 'Identify required endpoints' },
          { content: 'Plan authentication approach' },
        ],
      },
      {
        title: 'Implementation',
        steps: [
          { content: 'Create API client/service' },
          { content: 'Implement authentication' },
          { content: 'Add endpoint methods' },
          { content: 'Handle errors and retries' },
        ],
      },
      {
        title: 'Integration',
        steps: [
          { content: 'Connect to application' },
          { content: 'Add configuration' },
        ],
      },
      {
        title: 'Testing',
        steps: [
          { content: 'Test API calls' },
          { content: 'Test error scenarios' },
        ],
      },
    ],
  },
  {
    id: 'testing',
    name: 'Test Implementation',
    description: 'Standard workflow for writing tests',
    complexity: 'moderate',
    tags: ['test', 'unit test', 'e2e', 'coverage', 'testing'],
    phases: [
      {
        title: 'Setup',
        steps: [
          { content: 'Configure test environment' },
          { content: 'Identify test cases' },
        ],
      },
      {
        title: 'Write Tests',
        steps: [
          { content: 'Write unit tests' },
          { content: 'Write integration tests' },
          { content: 'Add edge case tests' },
        ],
      },
      {
        title: 'Verify',
        steps: [
          { content: 'Run all tests' },
          { content: 'Check coverage' },
        ],
      },
    ],
  },
  {
    id: 'database-migration',
    name: 'Database Migration',
    description: 'Standard workflow for database changes',
    complexity: 'complex',
    tags: ['database', 'migration', 'schema', 'sql', 'table'],
    phases: [
      {
        title: 'Planning',
        steps: [
          { content: 'Design schema changes' },
          { content: 'Plan data migration' },
          { content: 'Identify rollback strategy' },
        ],
      },
      {
        title: 'Implementation',
        steps: [
          { content: 'Create migration scripts' },
          { content: 'Update models/types' },
          { content: 'Update queries' },
        ],
      },
      {
        title: 'Testing',
        steps: [
          { content: 'Test migration on dev environment' },
          { content: 'Test rollback' },
          { content: 'Verify data integrity' },
        ],
      },
    ],
  },
];

// ============================================================================
// AutoPlanner Service
// ============================================================================

let autoPlannerInstance: AutoPlanner | null = null;

export class AutoPlanner {
  private config: AutoPlannerConfig;
  private customTemplates: PlanTemplate[] = [];

  constructor(config: Partial<AutoPlannerConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Analyze task and generate plan if complexity warrants it
   */
  async generatePlan(
    userMessage: string,
    planningConfig: PlanningConfig
  ): Promise<AutoPlanResult | null> {
    // Analyze complexity
    const complexity = taskComplexityAnalyzer.analyze(userMessage);

    // Check if auto-planning should be triggered
    if (!this.shouldAutoplan(complexity)) {
      return null;
    }

    // Find matching template
    const template = this.config.useTemplates
      ? this.findMatchingTemplate(userMessage, complexity.complexity)
      : undefined;

    // Generate plan
    const plan = template
      ? this.createPlanFromTemplate(userMessage, template, planningConfig)
      : this.createPlanFromScratch(userMessage, complexity, planningConfig);

    // Persist if enabled
    if (this.config.persistPlans) {
      await this.persistPlan(plan);
    }

    return {
      plan,
      template,
      complexity,
      autoGenerated: true,
    };
  }

  /**
   * Check if auto-planning should be triggered based on complexity
   */
  private shouldAutoplan(complexity: ComplexityAnalysis): boolean {
    if (!this.config.enableAutoPlanning) {
      return false;
    }

    const thresholdMap: Record<TaskComplexity, number> = {
      simple: 1,
      moderate: 2,
      complex: 3,
    };

    const complexityLevel = thresholdMap[complexity.complexity];
    const thresholdLevel = thresholdMap[this.config.complexityThreshold];

    return complexityLevel >= thresholdLevel;
  }

  /**
   * Find a matching template based on task keywords
   */
  private findMatchingTemplate(
    userMessage: string,
    complexity: TaskComplexity
  ): PlanTemplate | undefined {
    const lowerMessage = userMessage.toLowerCase();

    // Score each template
    const scored = [...PLAN_TEMPLATES, ...this.customTemplates].map(template => {
      let score = 0;

      // Tag matching
      for (const tag of template.tags) {
        if (lowerMessage.includes(tag.toLowerCase())) {
          score += 10;
        }
      }

      // Complexity matching bonus
      if (template.complexity === complexity) {
        score += 5;
      }

      return { template, score };
    });

    // Sort by score and return best match
    scored.sort((a, b) => b.score - a.score);
    return scored[0]?.score > 0 ? scored[0].template : undefined;
  }

  /**
   * Create a plan from a template
   */
  private createPlanFromTemplate(
    userMessage: string,
    template: PlanTemplate,
    config: PlanningConfig
  ): TaskPlan {
    const planId = `plan-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const now = Date.now();

    // Convert template phases to plan phases
    const phases: TaskPhase[] = template.phases.map((phase, phaseIndex) => ({
      id: `phase-${phaseIndex}`,
      title: phase.title,
      status: phaseIndex === 0 ? 'in_progress' : 'pending',
      steps: phase.steps.slice(0, this.config.maxStepsPerPhase).map((step, stepIndex) => ({
        id: `step-${phaseIndex}-${stepIndex}`,
        content: step.content,
        status: 'pending',
        activeForm: this.toActiveForm(step.content),
      })),
      notes: phase.notes,
    }));

    // Extract title from user message (first line or first 50 chars)
    const title = this.extractTitle(userMessage);

    return {
      id: planId,
      title,
      objective: userMessage,
      phases,
      createdAt: now,
      updatedAt: now,
      metadata: this.calculateMetadata(phases),
    };
  }

  /**
   * Create a plan from scratch when no template matches
   */
  private createPlanFromScratch(
    userMessage: string,
    complexity: ComplexityAnalysis,
    _config: PlanningConfig
  ): TaskPlan {
    const planId = `plan-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const now = Date.now();

    // Generate phases based on complexity
    const phases = this.generateDefaultPhases(complexity.complexity);

    // Extract title from user message
    const title = this.extractTitle(userMessage);

    return {
      id: planId,
      title,
      objective: userMessage,
      phases,
      createdAt: now,
      updatedAt: now,
      metadata: this.calculateMetadata(phases),
    };
  }

  /**
   * Generate default phases based on complexity
   */
  private generateDefaultPhases(complexity: TaskComplexity): TaskPhase[] {
    switch (complexity) {
      case 'simple':
        return [
          {
            id: 'phase-0',
            title: 'Implementation',
            status: 'in_progress',
            steps: [
              { id: 'step-0-0', content: 'Implement the requested change', status: 'pending', activeForm: 'Implementing the change' },
              { id: 'step-0-1', content: 'Verify the result', status: 'pending', activeForm: 'Verifying the result' },
            ],
          },
        ];

      case 'moderate':
        return [
          {
            id: 'phase-0',
            title: 'Analysis',
            status: 'in_progress',
            steps: [
              { id: 'step-0-0', content: 'Understand requirements', status: 'pending', activeForm: 'Understanding requirements' },
              { id: 'step-0-1', content: 'Identify affected areas', status: 'pending', activeForm: 'Identifying affected areas' },
            ],
          },
          {
            id: 'phase-1',
            title: 'Implementation',
            status: 'pending',
            steps: [
              { id: 'step-1-0', content: 'Make necessary changes', status: 'pending', activeForm: 'Making changes' },
              { id: 'step-1-1', content: 'Handle edge cases', status: 'pending', activeForm: 'Handling edge cases' },
            ],
          },
          {
            id: 'phase-2',
            title: 'Verification',
            status: 'pending',
            steps: [
              { id: 'step-2-0', content: 'Test the changes', status: 'pending', activeForm: 'Testing changes' },
            ],
          },
        ];

      case 'complex':
      default:
        return [
          {
            id: 'phase-0',
            title: 'Analysis & Planning',
            status: 'in_progress',
            steps: [
              { id: 'step-0-0', content: 'Analyze requirements thoroughly', status: 'pending', activeForm: 'Analyzing requirements' },
              { id: 'step-0-1', content: 'Map affected components', status: 'pending', activeForm: 'Mapping components' },
              { id: 'step-0-2', content: 'Design approach', status: 'pending', activeForm: 'Designing approach' },
            ],
          },
          {
            id: 'phase-1',
            title: 'Preparation',
            status: 'pending',
            steps: [
              { id: 'step-1-0', content: 'Set up necessary structure', status: 'pending', activeForm: 'Setting up structure' },
              { id: 'step-1-1', content: 'Prepare dependencies', status: 'pending', activeForm: 'Preparing dependencies' },
            ],
          },
          {
            id: 'phase-2',
            title: 'Core Implementation',
            status: 'pending',
            steps: [
              { id: 'step-2-0', content: 'Implement main functionality', status: 'pending', activeForm: 'Implementing main functionality' },
              { id: 'step-2-1', content: 'Add supporting code', status: 'pending', activeForm: 'Adding supporting code' },
              { id: 'step-2-2', content: 'Handle errors and edge cases', status: 'pending', activeForm: 'Handling edge cases' },
            ],
          },
          {
            id: 'phase-3',
            title: 'Integration & Testing',
            status: 'pending',
            steps: [
              { id: 'step-3-0', content: 'Integrate with existing code', status: 'pending', activeForm: 'Integrating code' },
              { id: 'step-3-1', content: 'Run tests', status: 'pending', activeForm: 'Running tests' },
              { id: 'step-3-2', content: 'Fix any issues', status: 'pending', activeForm: 'Fixing issues' },
            ],
          },
          {
            id: 'phase-4',
            title: 'Finalization',
            status: 'pending',
            steps: [
              { id: 'step-4-0', content: 'Clean up code', status: 'pending', activeForm: 'Cleaning up' },
              { id: 'step-4-1', content: 'Final verification', status: 'pending', activeForm: 'Final verification' },
            ],
          },
        ];
    }
  }

  /**
   * Convert imperative form to active form (e.g., "Implement X" -> "Implementing X")
   */
  private toActiveForm(content: string): string {
    // Simple conversion - prepend "ing" to first verb
    const words = content.split(' ');
    if (words.length > 0) {
      const firstWord = words[0].toLowerCase();
      // Handle common verb patterns
      if (firstWord.endsWith('e')) {
        words[0] = firstWord.slice(0, -1) + 'ing';
      } else if (firstWord.endsWith('y')) {
        words[0] = firstWord.slice(0, -1) + 'ying';
      } else {
        words[0] = firstWord + 'ing';
      }
      // Capitalize first letter
      words[0] = words[0].charAt(0).toUpperCase() + words[0].slice(1);
    }
    return words.join(' ');
  }

  /**
   * Extract a title from the user message
   */
  private extractTitle(message: string): string {
    // First line or first 60 chars
    const firstLine = message.split('\n')[0];
    if (firstLine.length <= 60) {
      return firstLine;
    }
    return firstLine.substring(0, 57) + '...';
  }

  /**
   * Calculate plan metadata
   */
  private calculateMetadata(phases: TaskPhase[]): {
    totalSteps: number;
    completedSteps: number;
    blockedSteps: number;
  } {
    let totalSteps = 0;
    let completedSteps = 0;
    let blockedSteps = 0;

    for (const phase of phases) {
      totalSteps += phase.steps.length;
      completedSteps += phase.steps.filter(s => s.status === 'completed').length;
      if (phase.status === 'blocked') {
        blockedSteps += phase.steps.filter(s => s.status === 'pending').length;
      }
    }

    return { totalSteps, completedSteps, blockedSteps };
  }

  /**
   * Persist plan to evolution persistence
   */
  private async persistPlan(plan: TaskPlan): Promise<void> {
    try {
      const persistence = getEvolutionPersistence();

      // Store as a strategy for future reference
      await persistence.createStrategy({
        name: `Plan: ${plan.title}`,
        description: plan.objective,
        steps: plan.phases.flatMap(p => p.steps.map(s => s.content)),
        successRate: 0,
        usageCount: 0,
        lastUsed: 0,
        tags: ['auto-plan', `complexity-${plan.phases.length <= 2 ? 'simple' : plan.phases.length <= 3 ? 'moderate' : 'complex'}`],
      });
    } catch (error) {
      console.error('[AutoPlanner] Failed to persist plan:', error);
    }
  }

  /**
   * Add a custom template
   */
  addTemplate(template: PlanTemplate): void {
    this.customTemplates.push(template);
  }

  /**
   * Get all available templates
   */
  getTemplates(): PlanTemplate[] {
    return [...PLAN_TEMPLATES, ...this.customTemplates];
  }

  /**
   * Update configuration
   */
  updateConfig(config: Partial<AutoPlannerConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get current configuration
   */
  getConfig(): AutoPlannerConfig {
    return { ...this.config };
  }

  /**
   * Format plan for display
   */
  formatPlanForDisplay(plan: TaskPlan): string {
    const lines: string[] = [];

    lines.push(`# ${plan.title}`);
    lines.push('');
    lines.push(`**Objective:** ${plan.objective}`);
    lines.push('');
    lines.push(`**Progress:** ${plan.metadata.completedSteps}/${plan.metadata.totalSteps} steps`);
    lines.push('');

    const statusIcons: Record<string, string> = {
      pending: '○',
      in_progress: '◐',
      completed: '●',
      blocked: '✖',
      skipped: '⊘',
    };

    for (const phase of plan.phases) {
      lines.push(`## ${statusIcons[phase.status]} ${phase.title}`);
      lines.push('');

      for (const step of phase.steps) {
        const icon = statusIcons[step.status];
        lines.push(`- ${icon} ${step.content}`);
      }

      lines.push('');
    }

    return lines.join('\n');
  }
}

/**
 * Get singleton instance
 */
export function getAutoPlanner(): AutoPlanner {
  if (!autoPlannerInstance) {
    autoPlannerInstance = new AutoPlanner();
  }
  return autoPlannerInstance;
}

/**
 * Initialize with custom config
 */
export function initAutoPlanner(config: Partial<AutoPlannerConfig>): AutoPlanner {
  autoPlannerInstance = new AutoPlanner(config);
  return autoPlannerInstance;
}
