// ============================================================================
// PPT Generate Tool - ç”Ÿæˆ PowerPoint æ¼”ç¤ºæ–‡ç¨¿ (.pptx)
// ============================================================================

import type { Tool, ToolContext, ToolExecutionResult } from '../toolRegistry';
import * as fs from 'fs';
import * as path from 'path';

// Use require for pptxgenjs (CJS compatible with Electron)
function getPptxGenJS() {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  const PptxGenJS = require('pptxgenjs');
  return PptxGenJS;
}

// PPT é£æ ¼ä¸»é¢˜
type PPTTheme = 'professional' | 'tech' | 'minimal' | 'vibrant';

interface PPTGenerateParams {
  topic: string;
  content?: string;
  slides_count?: number;
  theme?: PPTTheme;
  output_path?: string;
}

// ä¸»é¢˜é…ç½®
const themeConfigs: Record<PPTTheme, {
  titleColor: string;
  textColor: string;
  bgColor: string;
  accentColor: string;
  fontFace: string;
}> = {
  professional: {
    titleColor: '1a365d',
    textColor: '2d3748',
    bgColor: 'ffffff',
    accentColor: '3182ce',
    fontFace: 'Arial',
  },
  tech: {
    titleColor: '0d9488',
    textColor: 'e2e8f0',
    bgColor: '0f172a',
    accentColor: '22d3ee',
    fontFace: 'Consolas',
  },
  minimal: {
    titleColor: '1f2937',
    textColor: '4b5563',
    bgColor: 'f9fafb',
    accentColor: '6b7280',
    fontFace: 'Helvetica',
  },
  vibrant: {
    titleColor: '7c3aed',
    textColor: '1f2937',
    bgColor: 'ffffff',
    accentColor: 'ec4899',
    fontFace: 'Arial',
  },
};

export const pptGenerateTool: Tool = {
  name: 'ppt_generate',
  description: `ç”Ÿæˆ PowerPoint æ¼”ç¤ºæ–‡ç¨¿ï¼ˆ.pptx æ–‡ä»¶ï¼‰ã€‚

ç”Ÿæˆçš„æ–‡ä»¶å¯ä»¥ç›´æ¥ç”¨ Microsoft PowerPointã€Keynote æˆ– WPS æ‰“å¼€ã€‚

**ä¸»é¢˜é€‰é¡¹ï¼š**
- professional: ä¸“ä¸šå•†åŠ¡é£æ ¼ï¼ˆè“ç™½é…è‰²ï¼‰
- tech: ç§‘æŠ€é£æ ¼ï¼ˆæ·±è‰²èƒŒæ™¯ï¼Œé’è‰²ç‚¹ç¼€ï¼‰
- minimal: æç®€é£æ ¼ï¼ˆæµ…ç°èƒŒæ™¯ï¼‰
- vibrant: æ´»åŠ›é£æ ¼ï¼ˆç´«ç²‰é…è‰²ï¼‰

**ä½¿ç”¨ç¤ºä¾‹ï¼š**
\`\`\`
ppt_generate { "topic": "äº§å“ä»‹ç»", "slides_count": 5, "theme": "professional" }
ppt_generate { "topic": "æŠ€æœ¯åˆ†äº«", "content": "# ç¬¬ä¸€ç« \\n- è¦ç‚¹1\\n- è¦ç‚¹2", "theme": "tech" }
\`\`\``,
  generations: ['gen5', 'gen6', 'gen7', 'gen8'],
  requiresPermission: true,
  permissionLevel: 'write',
  inputSchema: {
    type: 'object',
    properties: {
      topic: {
        type: 'string',
        description: 'æ¼”ç¤ºæ–‡ç¨¿çš„ä¸»é¢˜/æ ‡é¢˜',
      },
      content: {
        type: 'string',
        description: 'è¯¦ç»†å†…å®¹å¤§çº²ï¼ˆMarkdown æ ¼å¼ï¼Œå¯é€‰ï¼‰',
      },
      slides_count: {
        type: 'number',
        description: 'å¹»ç¯ç‰‡æ•°é‡ï¼ˆé»˜è®¤: 5ï¼‰',
        default: 5,
      },
      theme: {
        type: 'string',
        enum: ['professional', 'tech', 'minimal', 'vibrant'],
        description: 'ä¸»é¢˜é£æ ¼ï¼ˆé»˜è®¤: professionalï¼‰',
        default: 'professional',
      },
      output_path: {
        type: 'string',
        description: 'è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤: å·¥ä½œç›®å½•ä¸‹çš„ presentation-{timestamp}.pptxï¼‰',
      },
    },
    required: ['topic'],
  },

  async execute(
    params: Record<string, unknown>,
    context: ToolContext
  ): Promise<ToolExecutionResult> {
    const {
      topic,
      content,
      slides_count = 5,
      theme = 'professional',
      output_path,
    } = params as unknown as PPTGenerateParams;

    try {
      // è·å– PptxGenJS
      const Pptx = getPptxGenJS();

      // ç¡®å®šè¾“å‡ºè·¯å¾„
      const timestamp = Date.now();
      const fileName = `presentation-${timestamp}.pptx`;
      const outputDir = output_path
        ? path.dirname(output_path)
        : context.workingDirectory;
      const finalPath = output_path || path.join(outputDir, fileName);

      // ç¡®ä¿ç›®å½•å­˜åœ¨
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      // åˆ›å»ºæ¼”ç¤ºæ–‡ç¨¿
      const pptx = new Pptx();
      const themeConfig = themeConfigs[theme as PPTTheme] || themeConfigs.professional;

      // è®¾ç½®æ¼”ç¤ºæ–‡ç¨¿å±æ€§
      pptx.author = 'Code Agent';
      pptx.title = topic;
      pptx.subject = topic;
      pptx.company = 'Generated by Code Agent';

      // è§£æå†…å®¹æˆ–ç”Ÿæˆå ä½å†…å®¹
      const slides = content
        ? parseContentToSlides(content, slides_count)
        : generatePlaceholderSlides(topic, slides_count);

      // ç”Ÿæˆå¹»ç¯ç‰‡
      for (let i = 0; i < slides.length; i++) {
        const slideData = slides[i];
        const slide = pptx.addSlide();

        // è®¾ç½®èƒŒæ™¯è‰²
        slide.background = { color: themeConfig.bgColor };

        if (i === 0) {
          // æ ‡é¢˜é¡µ
          slide.addText(slideData.title, {
            x: 0.5,
            y: '40%',
            w: '90%',
            h: 1.5,
            fontSize: 44,
            fontFace: themeConfig.fontFace,
            color: themeConfig.titleColor,
            bold: true,
            align: 'center',
          });

          if (slideData.subtitle) {
            slide.addText(slideData.subtitle, {
              x: 0.5,
              y: '55%',
              w: '90%',
              h: 0.8,
              fontSize: 24,
              fontFace: themeConfig.fontFace,
              color: themeConfig.textColor,
              align: 'center',
            });
          }
        } else if (i === slides.length - 1 && slideData.title.includes('è°¢è°¢') || slideData.title.includes('Thank')) {
          // ç»“æŸé¡µ
          slide.addText(slideData.title, {
            x: 0.5,
            y: '45%',
            w: '90%',
            h: 1.5,
            fontSize: 48,
            fontFace: themeConfig.fontFace,
            color: themeConfig.accentColor,
            bold: true,
            align: 'center',
          });
        } else {
          // å†…å®¹é¡µ
          // æ ‡é¢˜
          slide.addText(slideData.title, {
            x: 0.5,
            y: 0.5,
            w: '90%',
            h: 1,
            fontSize: 32,
            fontFace: themeConfig.fontFace,
            color: themeConfig.titleColor,
            bold: true,
          });

          // åˆ†éš”çº¿
          slide.addShape('rect', {
            x: 0.5,
            y: 1.4,
            w: 2,
            h: 0.05,
            fill: { color: themeConfig.accentColor },
          });

          // å†…å®¹è¦ç‚¹
          if (slideData.points && slideData.points.length > 0) {
            const bulletPoints = slideData.points.map(point => ({
              text: point,
              options: {
                bullet: { type: 'bullet', color: themeConfig.accentColor },
                fontSize: 20,
                fontFace: themeConfig.fontFace,
                color: themeConfig.textColor,
                paraSpaceAfter: 12,
              },
            }));

            slide.addText(bulletPoints, {
              x: 0.5,
              y: 1.8,
              w: '90%',
              h: 4,
              valign: 'top',
            });
          }
        }
      }

      // ä¿å­˜æ–‡ä»¶
      await pptx.writeFile({ fileName: finalPath });

      // è·å–æ–‡ä»¶ä¿¡æ¯
      const stats = fs.statSync(finalPath);

      return {
        success: true,
        output: `âœ… PPT å·²ç”Ÿæˆï¼

ğŸ“„ æ–‡ä»¶è·¯å¾„: ${finalPath}
ğŸ¨ ä¸»é¢˜é£æ ¼: ${theme}
ğŸ“Š å¹»ç¯ç‰‡æ•°é‡: ${slides.length}
ğŸ“¦ æ–‡ä»¶å¤§å°: ${formatFileSize(stats.size)}

ç‚¹å‡»ä¸Šæ–¹æ–‡ä»¶è·¯å¾„å¯ç›´æ¥æ‰“å¼€ã€‚`,
        metadata: {
          filePath: finalPath,
          fileName: path.basename(finalPath),
          fileSize: stats.size,
          slidesCount: slides.length,
          theme,
          // é™„ä»¶ä¿¡æ¯ - ä¾›å‰ç«¯å±•ç¤º
          attachment: {
            id: `ppt-${timestamp}`,
            type: 'file',
            category: 'document',
            name: path.basename(finalPath),
            path: finalPath,
            size: stats.size,
            mimeType: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
          },
        },
      };
    } catch (error: any) {
      return {
        success: false,
        error: `PPT ç”Ÿæˆå¤±è´¥: ${error.message}`,
      };
    }
  },
};

// è§£æ Markdown å†…å®¹ä¸ºå¹»ç¯ç‰‡æ•°æ®
interface SlideData {
  title: string;
  subtitle?: string;
  points?: string[];
}

function parseContentToSlides(content: string, maxSlides: number): SlideData[] {
  const slides: SlideData[] = [];
  const lines = content.split('\n').filter(l => l.trim());

  let currentSlide: SlideData | null = null;

  for (const line of lines) {
    const trimmed = line.trim();

    // ä¸€çº§æ ‡é¢˜ - æ–°å¹»ç¯ç‰‡
    if (trimmed.startsWith('# ')) {
      if (currentSlide) {
        slides.push(currentSlide);
      }
      currentSlide = {
        title: trimmed.replace(/^#\s*/, ''),
        points: [],
      };
    }
    // äºŒçº§æ ‡é¢˜ - å‰¯æ ‡é¢˜æˆ–æ–°å¹»ç¯ç‰‡
    else if (trimmed.startsWith('## ')) {
      if (currentSlide && !currentSlide.points?.length) {
        currentSlide.subtitle = trimmed.replace(/^##\s*/, '');
      } else {
        if (currentSlide) {
          slides.push(currentSlide);
        }
        currentSlide = {
          title: trimmed.replace(/^##\s*/, ''),
          points: [],
        };
      }
    }
    // ä¸‰çº§æ ‡é¢˜ - ä½œä¸ºè¦ç‚¹
    else if (trimmed.startsWith('### ')) {
      if (currentSlide) {
        currentSlide.points = currentSlide.points || [];
        currentSlide.points.push(trimmed.replace(/^###\s*/, ''));
      }
    }
    // åˆ—è¡¨é¡¹
    else if (trimmed.startsWith('- ') || trimmed.startsWith('* ') || trimmed.match(/^\d+\.\s/)) {
      if (currentSlide) {
        currentSlide.points = currentSlide.points || [];
        currentSlide.points.push(trimmed.replace(/^[-*]\s*/, '').replace(/^\d+\.\s*/, ''));
      }
    }
    // æ™®é€šæ–‡æœ¬è¡Œä½œä¸ºå‰¯æ ‡é¢˜æˆ–è¦ç‚¹
    else if (trimmed && currentSlide) {
      if (!currentSlide.subtitle && !currentSlide.points?.length) {
        currentSlide.subtitle = trimmed;
      } else {
        currentSlide.points = currentSlide.points || [];
        currentSlide.points.push(trimmed);
      }
    }
  }

  if (currentSlide) {
    slides.push(currentSlide);
  }

  // å¦‚æœæ²¡æœ‰è§£æå‡ºå¹»ç¯ç‰‡ï¼Œåˆ›å»ºä¸€ä¸ªåŸºäºå†…å®¹çš„å¹»ç¯ç‰‡
  if (slides.length === 0) {
    slides.push({
      title: 'å†…å®¹æ¦‚è¿°',
      points: content.split('\n').filter(l => l.trim()).slice(0, 5),
    });
  }

  // é™åˆ¶å¹»ç¯ç‰‡æ•°é‡
  return slides.slice(0, maxSlides);
}

// ç”Ÿæˆå ä½å¹»ç¯ç‰‡
function generatePlaceholderSlides(topic: string, count: number): SlideData[] {
  const slides: SlideData[] = [
    {
      title: topic,
      subtitle: 'Generated by Code Agent',
    },
  ];

  const sectionTitles = [
    'èƒŒæ™¯ä»‹ç»',
    'æ ¸å¿ƒå†…å®¹',
    'è¯¦ç»†åˆ†æ',
    'æ¡ˆä¾‹å±•ç¤º',
    'å®æ–½æ–¹æ¡ˆ',
    'é¢„æœŸæ•ˆæœ',
    'æ€»ç»“å±•æœ›',
  ];

  for (let i = 0; i < count - 2 && i < sectionTitles.length; i++) {
    slides.push({
      title: sectionTitles[i],
      points: [
        'è¦ç‚¹å†…å®¹ 1',
        'è¦ç‚¹å†…å®¹ 2',
        'è¦ç‚¹å†…å®¹ 3',
      ],
    });
  }

  slides.push({
    title: 'è°¢è°¢è§‚çœ‹',
  });

  return slides;
}

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
